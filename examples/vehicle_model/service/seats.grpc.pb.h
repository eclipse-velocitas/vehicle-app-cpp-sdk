// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: service/seats.proto

#ifndef GRPC_service_2fseats_2eproto__INCLUDED
#define GRPC_service_2fseats_2eproto__INCLUDED

#include "service/seats.pb.h"

#include <functional>
#include <grpcpp/impl/codegen/async_generic_service.h>
#include <grpcpp/impl/codegen/async_stream.h>
#include <grpcpp/impl/codegen/async_unary_call.h>
#include <grpcpp/impl/codegen/client_callback.h>
#include <grpcpp/impl/codegen/client_context.h>
#include <grpcpp/impl/codegen/completion_queue.h>
#include <grpcpp/impl/codegen/message_allocator.h>
#include <grpcpp/impl/codegen/method_handler.h>
#include <grpcpp/impl/codegen/proto_utils.h>
#include <grpcpp/impl/codegen/rpc_method.h>
#include <grpcpp/impl/codegen/server_callback.h>
#include <grpcpp/impl/codegen/server_callback_handlers.h>
#include <grpcpp/impl/codegen/server_context.h>
#include <grpcpp/impl/codegen/service_type.h>
#include <grpcpp/impl/codegen/status.h>
#include <grpcpp/impl/codegen/stub_options.h>
#include <grpcpp/impl/codegen/sync_stream.h>

namespace sdv {
namespace edge {
namespace comfort {
namespace seats {
namespace v1 {

// *
// @brief Seats service for getting and controlling the positions of the seats and their
//        components in the vehicle.
//        This definition corresponds to the COVESA Vehicle Service Catalog (VSC) comfort
//        seats service definition (https://github.com/COVESA/vehicle_service_catalog)
class Seats final {
public:
    static constexpr char const* service_full_name() { return "sdv.edge.comfort.seats.v1.Seats"; }
    class StubInterface {
    public:
        virtual ~StubInterface() {}
        // * Set the desired seat position
        //
        //  Returns gRPC status codes:
        //   * OK - Seat movement started
        //   * OUT_OF_RANGE - The addressed seat is not present in this vehicle
        //   * INVALID_ARGUMENT - At least one of the requested component positions is invalid
        //   * INTERNAL - A seat service internal error happened - see error message for details
        virtual ::grpc::Status Move(::grpc::ClientContext*                              context,
                                    const ::sdv::edge::comfort::seats::v1::MoveRequest& request,
                                    ::sdv::edge::comfort::seats::v1::MoveReply* response) = 0;
        std::unique_ptr<
            ::grpc::ClientAsyncResponseReaderInterface<::sdv::edge::comfort::seats::v1::MoveReply>>
        AsyncMove(::grpc::ClientContext*                              context,
                  const ::sdv::edge::comfort::seats::v1::MoveRequest& request,
                  ::grpc::CompletionQueue*                            cq) {
            return std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<
                ::sdv::edge::comfort::seats::v1::MoveReply>>(AsyncMoveRaw(context, request, cq));
        }
        std::unique_ptr<
            ::grpc::ClientAsyncResponseReaderInterface<::sdv::edge::comfort::seats::v1::MoveReply>>
        PrepareAsyncMove(::grpc::ClientContext*                              context,
                         const ::sdv::edge::comfort::seats::v1::MoveRequest& request,
                         ::grpc::CompletionQueue*                            cq) {
            return std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<
                ::sdv::edge::comfort::seats::v1::MoveReply>>(
                PrepareAsyncMoveRaw(context, request, cq));
        }
        // Set a seat component position
        //
        //  Returns gRPC status codes:
        //   * OK - Seat movement started
        //   * OUT_OF_RANGE - The addressed seat is not present in this vehicle
        //   * NOT_FOUND - The addressed seat component is not supported by this seat/vehicle
        //   * INVALID_ARGUMENT - At least one of the requested component positions is invalid
        //   * INTERNAL - A seat service internal error happened - see error message for details
        virtual ::grpc::Status
        MoveComponent(::grpc::ClientContext*                                       context,
                      const ::sdv::edge::comfort::seats::v1::MoveComponentRequest& request,
                      ::sdv::edge::comfort::seats::v1::MoveComponentReply*         response) = 0;
        std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<
            ::sdv::edge::comfort::seats::v1::MoveComponentReply>>
        AsyncMoveComponent(::grpc::ClientContext*                                       context,
                           const ::sdv::edge::comfort::seats::v1::MoveComponentRequest& request,
                           ::grpc::CompletionQueue*                                     cq) {
            return std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<
                ::sdv::edge::comfort::seats::v1::MoveComponentReply>>(
                AsyncMoveComponentRaw(context, request, cq));
        }
        std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<
            ::sdv::edge::comfort::seats::v1::MoveComponentReply>>
        PrepareAsyncMoveComponent(
            ::grpc::ClientContext*                                       context,
            const ::sdv::edge::comfort::seats::v1::MoveComponentRequest& request,
            ::grpc::CompletionQueue*                                     cq) {
            return std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<
                ::sdv::edge::comfort::seats::v1::MoveComponentReply>>(
                PrepareAsyncMoveComponentRaw(context, request, cq));
        }
        // Get the current position of the addressed seat
        //
        //  Returns gRPC status codes:
        //   * OK - Seat positions returned
        //   * OUT_OF_RANGE - The addressed seat is not present in this vehicle
        virtual ::grpc::Status
        CurrentPosition(::grpc::ClientContext*                                         context,
                        const ::sdv::edge::comfort::seats::v1::CurrentPositionRequest& request,
                        ::sdv::edge::comfort::seats::v1::CurrentPositionReply* response) = 0;
        std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<
            ::sdv::edge::comfort::seats::v1::CurrentPositionReply>>
        AsyncCurrentPosition(::grpc::ClientContext*                                         context,
                             const ::sdv::edge::comfort::seats::v1::CurrentPositionRequest& request,
                             ::grpc::CompletionQueue*                                       cq) {
            return std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<
                ::sdv::edge::comfort::seats::v1::CurrentPositionReply>>(
                AsyncCurrentPositionRaw(context, request, cq));
        }
        std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<
            ::sdv::edge::comfort::seats::v1::CurrentPositionReply>>
        PrepareAsyncCurrentPosition(
            ::grpc::ClientContext*                                         context,
            const ::sdv::edge::comfort::seats::v1::CurrentPositionRequest& request,
            ::grpc::CompletionQueue*                                       cq) {
            return std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<
                ::sdv::edge::comfort::seats::v1::CurrentPositionReply>>(
                PrepareAsyncCurrentPositionRaw(context, request, cq));
        }
        class async_interface {
        public:
            virtual ~async_interface() {}
            // * Set the desired seat position
            //
            //  Returns gRPC status codes:
            //   * OK - Seat movement started
            //   * OUT_OF_RANGE - The addressed seat is not present in this vehicle
            //   * INVALID_ARGUMENT - At least one of the requested component positions is invalid
            //   * INTERNAL - A seat service internal error happened - see error message for details
            virtual void Move(::grpc::ClientContext*                              context,
                              const ::sdv::edge::comfort::seats::v1::MoveRequest* request,
                              ::sdv::edge::comfort::seats::v1::MoveReply*         response,
                              std::function<void(::grpc::Status)>) = 0;
            virtual void Move(::grpc::ClientContext*                              context,
                              const ::sdv::edge::comfort::seats::v1::MoveRequest* request,
                              ::sdv::edge::comfort::seats::v1::MoveReply*         response,
                              ::grpc::ClientUnaryReactor*                         reactor) = 0;
            // Set a seat component position
            //
            //  Returns gRPC status codes:
            //   * OK - Seat movement started
            //   * OUT_OF_RANGE - The addressed seat is not present in this vehicle
            //   * NOT_FOUND - The addressed seat component is not supported by this seat/vehicle
            //   * INVALID_ARGUMENT - At least one of the requested component positions is invalid
            //   * INTERNAL - A seat service internal error happened - see error message for details
            virtual void
            MoveComponent(::grpc::ClientContext*                                       context,
                          const ::sdv::edge::comfort::seats::v1::MoveComponentRequest* request,
                          ::sdv::edge::comfort::seats::v1::MoveComponentReply*         response,
                          std::function<void(::grpc::Status)>) = 0;
            virtual void
            MoveComponent(::grpc::ClientContext*                                       context,
                          const ::sdv::edge::comfort::seats::v1::MoveComponentRequest* request,
                          ::sdv::edge::comfort::seats::v1::MoveComponentReply*         response,
                          ::grpc::ClientUnaryReactor*                                  reactor) = 0;
            // Get the current position of the addressed seat
            //
            //  Returns gRPC status codes:
            //   * OK - Seat positions returned
            //   * OUT_OF_RANGE - The addressed seat is not present in this vehicle
            virtual void
            CurrentPosition(::grpc::ClientContext*                                         context,
                            const ::sdv::edge::comfort::seats::v1::CurrentPositionRequest* request,
                            ::sdv::edge::comfort::seats::v1::CurrentPositionReply*         response,
                            std::function<void(::grpc::Status)>) = 0;
            virtual void
            CurrentPosition(::grpc::ClientContext*                                         context,
                            const ::sdv::edge::comfort::seats::v1::CurrentPositionRequest* request,
                            ::sdv::edge::comfort::seats::v1::CurrentPositionReply*         response,
                            ::grpc::ClientUnaryReactor* reactor) = 0;
        };
        typedef class async_interface  experimental_async_interface;
        virtual class async_interface* async() { return nullptr; }
        class async_interface*         experimental_async() {
                    return async();
        }

    private:
        virtual ::grpc::ClientAsyncResponseReaderInterface<
            ::sdv::edge::comfort::seats::v1::MoveReply>*
        AsyncMoveRaw(::grpc::ClientContext*                              context,
                     const ::sdv::edge::comfort::seats::v1::MoveRequest& request,
                     ::grpc::CompletionQueue*                            cq) = 0;
        virtual ::grpc::ClientAsyncResponseReaderInterface<
            ::sdv::edge::comfort::seats::v1::MoveReply>*
        PrepareAsyncMoveRaw(::grpc::ClientContext*                              context,
                            const ::sdv::edge::comfort::seats::v1::MoveRequest& request,
                            ::grpc::CompletionQueue*                            cq) = 0;
        virtual ::grpc::ClientAsyncResponseReaderInterface<
            ::sdv::edge::comfort::seats::v1::MoveComponentReply>*
        AsyncMoveComponentRaw(::grpc::ClientContext*                                       context,
                              const ::sdv::edge::comfort::seats::v1::MoveComponentRequest& request,
                              ::grpc::CompletionQueue*                                     cq) = 0;
        virtual ::grpc::ClientAsyncResponseReaderInterface<
            ::sdv::edge::comfort::seats::v1::MoveComponentReply>*
        PrepareAsyncMoveComponentRaw(
            ::grpc::ClientContext*                                       context,
            const ::sdv::edge::comfort::seats::v1::MoveComponentRequest& request,
            ::grpc::CompletionQueue*                                     cq) = 0;
        virtual ::grpc::ClientAsyncResponseReaderInterface<
            ::sdv::edge::comfort::seats::v1::CurrentPositionReply>*
        AsyncCurrentPositionRaw(
            ::grpc::ClientContext*                                         context,
            const ::sdv::edge::comfort::seats::v1::CurrentPositionRequest& request,
            ::grpc::CompletionQueue*                                       cq) = 0;
        virtual ::grpc::ClientAsyncResponseReaderInterface<
            ::sdv::edge::comfort::seats::v1::CurrentPositionReply>*
        PrepareAsyncCurrentPositionRaw(
            ::grpc::ClientContext*                                         context,
            const ::sdv::edge::comfort::seats::v1::CurrentPositionRequest& request,
            ::grpc::CompletionQueue*                                       cq) = 0;
    };
    class Stub final : public StubInterface {
    public:
        Stub(const std::shared_ptr<::grpc::ChannelInterface>& channel,
             const ::grpc::StubOptions&                       options = ::grpc::StubOptions());
        ::grpc::Status Move(::grpc::ClientContext*                              context,
                            const ::sdv::edge::comfort::seats::v1::MoveRequest& request,
                            ::sdv::edge::comfort::seats::v1::MoveReply*         response) override;
        std::unique_ptr<
            ::grpc::ClientAsyncResponseReader<::sdv::edge::comfort::seats::v1::MoveReply>>
        AsyncMove(::grpc::ClientContext*                              context,
                  const ::sdv::edge::comfort::seats::v1::MoveRequest& request,
                  ::grpc::CompletionQueue*                            cq) {
            return std::unique_ptr<
                ::grpc::ClientAsyncResponseReader<::sdv::edge::comfort::seats::v1::MoveReply>>(
                AsyncMoveRaw(context, request, cq));
        }
        std::unique_ptr<
            ::grpc::ClientAsyncResponseReader<::sdv::edge::comfort::seats::v1::MoveReply>>
        PrepareAsyncMove(::grpc::ClientContext*                              context,
                         const ::sdv::edge::comfort::seats::v1::MoveRequest& request,
                         ::grpc::CompletionQueue*                            cq) {
            return std::unique_ptr<
                ::grpc::ClientAsyncResponseReader<::sdv::edge::comfort::seats::v1::MoveReply>>(
                PrepareAsyncMoveRaw(context, request, cq));
        }
        ::grpc::Status
        MoveComponent(::grpc::ClientContext*                                       context,
                      const ::sdv::edge::comfort::seats::v1::MoveComponentRequest& request,
                      ::sdv::edge::comfort::seats::v1::MoveComponentReply* response) override;
        std::unique_ptr<
            ::grpc::ClientAsyncResponseReader<::sdv::edge::comfort::seats::v1::MoveComponentReply>>
        AsyncMoveComponent(::grpc::ClientContext*                                       context,
                           const ::sdv::edge::comfort::seats::v1::MoveComponentRequest& request,
                           ::grpc::CompletionQueue*                                     cq) {
            return std::unique_ptr<::grpc::ClientAsyncResponseReader<
                ::sdv::edge::comfort::seats::v1::MoveComponentReply>>(
                AsyncMoveComponentRaw(context, request, cq));
        }
        std::unique_ptr<
            ::grpc::ClientAsyncResponseReader<::sdv::edge::comfort::seats::v1::MoveComponentReply>>
        PrepareAsyncMoveComponent(
            ::grpc::ClientContext*                                       context,
            const ::sdv::edge::comfort::seats::v1::MoveComponentRequest& request,
            ::grpc::CompletionQueue*                                     cq) {
            return std::unique_ptr<::grpc::ClientAsyncResponseReader<
                ::sdv::edge::comfort::seats::v1::MoveComponentReply>>(
                PrepareAsyncMoveComponentRaw(context, request, cq));
        }
        ::grpc::Status
        CurrentPosition(::grpc::ClientContext*                                         context,
                        const ::sdv::edge::comfort::seats::v1::CurrentPositionRequest& request,
                        ::sdv::edge::comfort::seats::v1::CurrentPositionReply* response) override;
        std::unique_ptr<::grpc::ClientAsyncResponseReader<
            ::sdv::edge::comfort::seats::v1::CurrentPositionReply>>
        AsyncCurrentPosition(::grpc::ClientContext*                                         context,
                             const ::sdv::edge::comfort::seats::v1::CurrentPositionRequest& request,
                             ::grpc::CompletionQueue*                                       cq) {
            return std::unique_ptr<::grpc::ClientAsyncResponseReader<
                ::sdv::edge::comfort::seats::v1::CurrentPositionReply>>(
                AsyncCurrentPositionRaw(context, request, cq));
        }
        std::unique_ptr<::grpc::ClientAsyncResponseReader<
            ::sdv::edge::comfort::seats::v1::CurrentPositionReply>>
        PrepareAsyncCurrentPosition(
            ::grpc::ClientContext*                                         context,
            const ::sdv::edge::comfort::seats::v1::CurrentPositionRequest& request,
            ::grpc::CompletionQueue*                                       cq) {
            return std::unique_ptr<::grpc::ClientAsyncResponseReader<
                ::sdv::edge::comfort::seats::v1::CurrentPositionReply>>(
                PrepareAsyncCurrentPositionRaw(context, request, cq));
        }
        class async final : public StubInterface::async_interface {
        public:
            void Move(::grpc::ClientContext*                              context,
                      const ::sdv::edge::comfort::seats::v1::MoveRequest* request,
                      ::sdv::edge::comfort::seats::v1::MoveReply*         response,
                      std::function<void(::grpc::Status)>) override;
            void Move(::grpc::ClientContext*                              context,
                      const ::sdv::edge::comfort::seats::v1::MoveRequest* request,
                      ::sdv::edge::comfort::seats::v1::MoveReply*         response,
                      ::grpc::ClientUnaryReactor*                         reactor) override;
            void MoveComponent(::grpc::ClientContext*                                       context,
                               const ::sdv::edge::comfort::seats::v1::MoveComponentRequest* request,
                               ::sdv::edge::comfort::seats::v1::MoveComponentReply* response,
                               std::function<void(::grpc::Status)>) override;
            void MoveComponent(::grpc::ClientContext*                                       context,
                               const ::sdv::edge::comfort::seats::v1::MoveComponentRequest* request,
                               ::sdv::edge::comfort::seats::v1::MoveComponentReply* response,
                               ::grpc::ClientUnaryReactor* reactor) override;
            void
            CurrentPosition(::grpc::ClientContext*                                         context,
                            const ::sdv::edge::comfort::seats::v1::CurrentPositionRequest* request,
                            ::sdv::edge::comfort::seats::v1::CurrentPositionReply*         response,
                            std::function<void(::grpc::Status)>) override;
            void
            CurrentPosition(::grpc::ClientContext*                                         context,
                            const ::sdv::edge::comfort::seats::v1::CurrentPositionRequest* request,
                            ::sdv::edge::comfort::seats::v1::CurrentPositionReply*         response,
                            ::grpc::ClientUnaryReactor* reactor) override;

        private:
            friend class Stub;
            explicit async(Stub* stub)
                : stub_(stub) {}
            Stub* stub() { return stub_; }
            Stub* stub_;
        };
        class async* async() override {
            return &async_stub_;
        }

    private:
        std::shared_ptr<::grpc::ChannelInterface> channel_;
        class async                               async_stub_ {
            this
        };
        ::grpc::ClientAsyncResponseReader<::sdv::edge::comfort::seats::v1::MoveReply>*
        AsyncMoveRaw(::grpc::ClientContext*                              context,
                     const ::sdv::edge::comfort::seats::v1::MoveRequest& request,
                     ::grpc::CompletionQueue*                            cq) override;
        ::grpc::ClientAsyncResponseReader<::sdv::edge::comfort::seats::v1::MoveReply>*
        PrepareAsyncMoveRaw(::grpc::ClientContext*                              context,
                            const ::sdv::edge::comfort::seats::v1::MoveRequest& request,
                            ::grpc::CompletionQueue*                            cq) override;
        ::grpc::ClientAsyncResponseReader<::sdv::edge::comfort::seats::v1::MoveComponentReply>*
        AsyncMoveComponentRaw(::grpc::ClientContext*                                       context,
                              const ::sdv::edge::comfort::seats::v1::MoveComponentRequest& request,
                              ::grpc::CompletionQueue* cq) override;
        ::grpc::ClientAsyncResponseReader<::sdv::edge::comfort::seats::v1::MoveComponentReply>*
        PrepareAsyncMoveComponentRaw(
            ::grpc::ClientContext*                                       context,
            const ::sdv::edge::comfort::seats::v1::MoveComponentRequest& request,
            ::grpc::CompletionQueue*                                     cq) override;
        ::grpc::ClientAsyncResponseReader<::sdv::edge::comfort::seats::v1::CurrentPositionReply>*
        AsyncCurrentPositionRaw(
            ::grpc::ClientContext*                                         context,
            const ::sdv::edge::comfort::seats::v1::CurrentPositionRequest& request,
            ::grpc::CompletionQueue*                                       cq) override;
        ::grpc::ClientAsyncResponseReader<::sdv::edge::comfort::seats::v1::CurrentPositionReply>*
        PrepareAsyncCurrentPositionRaw(
            ::grpc::ClientContext*                                         context,
            const ::sdv::edge::comfort::seats::v1::CurrentPositionRequest& request,
            ::grpc::CompletionQueue*                                       cq) override;
        const ::grpc::internal::RpcMethod rpcmethod_Move_;
        const ::grpc::internal::RpcMethod rpcmethod_MoveComponent_;
        const ::grpc::internal::RpcMethod rpcmethod_CurrentPosition_;
    };
    static std::unique_ptr<Stub>
    NewStub(const std::shared_ptr<::grpc::ChannelInterface>& channel,
            const ::grpc::StubOptions&                       options = ::grpc::StubOptions());

    class Service : public ::grpc::Service {
    public:
        Service();
        virtual ~Service();
        // * Set the desired seat position
        //
        //  Returns gRPC status codes:
        //   * OK - Seat movement started
        //   * OUT_OF_RANGE - The addressed seat is not present in this vehicle
        //   * INVALID_ARGUMENT - At least one of the requested component positions is invalid
        //   * INTERNAL - A seat service internal error happened - see error message for details
        virtual ::grpc::Status Move(::grpc::ServerContext*                              context,
                                    const ::sdv::edge::comfort::seats::v1::MoveRequest* request,
                                    ::sdv::edge::comfort::seats::v1::MoveReply*         response);
        // Set a seat component position
        //
        //  Returns gRPC status codes:
        //   * OK - Seat movement started
        //   * OUT_OF_RANGE - The addressed seat is not present in this vehicle
        //   * NOT_FOUND - The addressed seat component is not supported by this seat/vehicle
        //   * INVALID_ARGUMENT - At least one of the requested component positions is invalid
        //   * INTERNAL - A seat service internal error happened - see error message for details
        virtual ::grpc::Status
        MoveComponent(::grpc::ServerContext*                                       context,
                      const ::sdv::edge::comfort::seats::v1::MoveComponentRequest* request,
                      ::sdv::edge::comfort::seats::v1::MoveComponentReply*         response);
        // Get the current position of the addressed seat
        //
        //  Returns gRPC status codes:
        //   * OK - Seat positions returned
        //   * OUT_OF_RANGE - The addressed seat is not present in this vehicle
        virtual ::grpc::Status
        CurrentPosition(::grpc::ServerContext*                                         context,
                        const ::sdv::edge::comfort::seats::v1::CurrentPositionRequest* request,
                        ::sdv::edge::comfort::seats::v1::CurrentPositionReply*         response);
    };
    template <class BaseClass> class WithAsyncMethod_Move : public BaseClass {
    private:
        void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}

    public:
        WithAsyncMethod_Move() { ::grpc::Service::MarkMethodAsync(0); }
        ~WithAsyncMethod_Move() override { BaseClassMustBeDerivedFromService(this); }
        // disable synchronous version of this method
        ::grpc::Status Move(::grpc::ServerContext* /*context*/,
                            const ::sdv::edge::comfort::seats::v1::MoveRequest* /*request*/,
                            ::sdv::edge::comfort::seats::v1::MoveReply* /*response*/) override {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
        void RequestMove(
            ::grpc::ServerContext* context, ::sdv::edge::comfort::seats::v1::MoveRequest* request,
            ::grpc::ServerAsyncResponseWriter<::sdv::edge::comfort::seats::v1::MoveReply>* response,
            ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq,
            void* tag) {
            ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq,
                                               notification_cq, tag);
        }
    };
    template <class BaseClass> class WithAsyncMethod_MoveComponent : public BaseClass {
    private:
        void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}

    public:
        WithAsyncMethod_MoveComponent() { ::grpc::Service::MarkMethodAsync(1); }
        ~WithAsyncMethod_MoveComponent() override { BaseClassMustBeDerivedFromService(this); }
        // disable synchronous version of this method
        ::grpc::Status
        MoveComponent(::grpc::ServerContext* /*context*/,
                      const ::sdv::edge::comfort::seats::v1::MoveComponentRequest* /*request*/,
                      ::sdv::edge::comfort::seats::v1::MoveComponentReply* /*response*/) override {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
        void RequestMoveComponent(
            ::grpc::ServerContext*                                 context,
            ::sdv::edge::comfort::seats::v1::MoveComponentRequest* request,
            ::grpc::ServerAsyncResponseWriter<::sdv::edge::comfort::seats::v1::MoveComponentReply>*
                                     response,
            ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq,
            void* tag) {
            ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq,
                                               notification_cq, tag);
        }
    };
    template <class BaseClass> class WithAsyncMethod_CurrentPosition : public BaseClass {
    private:
        void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}

    public:
        WithAsyncMethod_CurrentPosition() { ::grpc::Service::MarkMethodAsync(2); }
        ~WithAsyncMethod_CurrentPosition() override { BaseClassMustBeDerivedFromService(this); }
        // disable synchronous version of this method
        ::grpc::Status CurrentPosition(
            ::grpc::ServerContext* /*context*/,
            const ::sdv::edge::comfort::seats::v1::CurrentPositionRequest* /*request*/,
            ::sdv::edge::comfort::seats::v1::CurrentPositionReply* /*response*/) override {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
        void
        RequestCurrentPosition(::grpc::ServerContext*                                   context,
                               ::sdv::edge::comfort::seats::v1::CurrentPositionRequest* request,
                               ::grpc::ServerAsyncResponseWriter<
                                   ::sdv::edge::comfort::seats::v1::CurrentPositionReply>* response,
                               ::grpc::CompletionQueue*       new_call_cq,
                               ::grpc::ServerCompletionQueue* notification_cq, void* tag) {
            ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq,
                                               notification_cq, tag);
        }
    };
    typedef WithAsyncMethod_Move<
        WithAsyncMethod_MoveComponent<WithAsyncMethod_CurrentPosition<Service>>>
        AsyncService;
    template <class BaseClass> class WithCallbackMethod_Move : public BaseClass {
    private:
        void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}

    public:
        WithCallbackMethod_Move() {
            ::grpc::Service::MarkMethodCallback(
                0, new ::grpc::internal::CallbackUnaryHandler<
                       ::sdv::edge::comfort::seats::v1::MoveRequest,
                       ::sdv::edge::comfort::seats::v1::MoveReply>(
                       [this](::grpc::CallbackServerContext*                      context,
                              const ::sdv::edge::comfort::seats::v1::MoveRequest* request,
                              ::sdv::edge::comfort::seats::v1::MoveReply*         response) {
                           return this->Move(context, request, response);
                       }));
        }
        void SetMessageAllocatorFor_Move(
            ::grpc::MessageAllocator<::sdv::edge::comfort::seats::v1::MoveRequest,
                                     ::sdv::edge::comfort::seats::v1::MoveReply>* allocator) {
            ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
            static_cast<::grpc::internal::CallbackUnaryHandler<
                ::sdv::edge::comfort::seats::v1::MoveRequest,
                ::sdv::edge::comfort::seats::v1::MoveReply>*>(handler)
                ->SetMessageAllocator(allocator);
        }
        ~WithCallbackMethod_Move() override { BaseClassMustBeDerivedFromService(this); }
        // disable synchronous version of this method
        ::grpc::Status Move(::grpc::ServerContext* /*context*/,
                            const ::sdv::edge::comfort::seats::v1::MoveRequest* /*request*/,
                            ::sdv::edge::comfort::seats::v1::MoveReply* /*response*/) override {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
        virtual ::grpc::ServerUnaryReactor*
        Move(::grpc::CallbackServerContext* /*context*/,
             const ::sdv::edge::comfort::seats::v1::MoveRequest* /*request*/,
             ::sdv::edge::comfort::seats::v1::MoveReply* /*response*/) {
            return nullptr;
        }
    };
    template <class BaseClass> class WithCallbackMethod_MoveComponent : public BaseClass {
    private:
        void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}

    public:
        WithCallbackMethod_MoveComponent() {
            ::grpc::Service::MarkMethodCallback(
                1, new ::grpc::internal::CallbackUnaryHandler<
                       ::sdv::edge::comfort::seats::v1::MoveComponentRequest,
                       ::sdv::edge::comfort::seats::v1::MoveComponentReply>(
                       [this](::grpc::CallbackServerContext*                               context,
                              const ::sdv::edge::comfort::seats::v1::MoveComponentRequest* request,
                              ::sdv::edge::comfort::seats::v1::MoveComponentReply* response) {
                           return this->MoveComponent(context, request, response);
                       }));
        }
        void SetMessageAllocatorFor_MoveComponent(
            ::grpc::MessageAllocator<::sdv::edge::comfort::seats::v1::MoveComponentRequest,
                                     ::sdv::edge::comfort::seats::v1::MoveComponentReply>*
                allocator) {
            ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(1);
            static_cast<::grpc::internal::CallbackUnaryHandler<
                ::sdv::edge::comfort::seats::v1::MoveComponentRequest,
                ::sdv::edge::comfort::seats::v1::MoveComponentReply>*>(handler)
                ->SetMessageAllocator(allocator);
        }
        ~WithCallbackMethod_MoveComponent() override { BaseClassMustBeDerivedFromService(this); }
        // disable synchronous version of this method
        ::grpc::Status
        MoveComponent(::grpc::ServerContext* /*context*/,
                      const ::sdv::edge::comfort::seats::v1::MoveComponentRequest* /*request*/,
                      ::sdv::edge::comfort::seats::v1::MoveComponentReply* /*response*/) override {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
        virtual ::grpc::ServerUnaryReactor*
        MoveComponent(::grpc::CallbackServerContext* /*context*/,
                      const ::sdv::edge::comfort::seats::v1::MoveComponentRequest* /*request*/,
                      ::sdv::edge::comfort::seats::v1::MoveComponentReply* /*response*/) {
            return nullptr;
        }
    };
    template <class BaseClass> class WithCallbackMethod_CurrentPosition : public BaseClass {
    private:
        void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}

    public:
        WithCallbackMethod_CurrentPosition() {
            ::grpc::Service::MarkMethodCallback(
                2,
                new ::grpc::internal::CallbackUnaryHandler<
                    ::sdv::edge::comfort::seats::v1::CurrentPositionRequest,
                    ::sdv::edge::comfort::seats::v1::CurrentPositionReply>(
                    [this](::grpc::CallbackServerContext*                                 context,
                           const ::sdv::edge::comfort::seats::v1::CurrentPositionRequest* request,
                           ::sdv::edge::comfort::seats::v1::CurrentPositionReply* response) {
                        return this->CurrentPosition(context, request, response);
                    }));
        }
        void SetMessageAllocatorFor_CurrentPosition(
            ::grpc::MessageAllocator<::sdv::edge::comfort::seats::v1::CurrentPositionRequest,
                                     ::sdv::edge::comfort::seats::v1::CurrentPositionReply>*
                allocator) {
            ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(2);
            static_cast<::grpc::internal::CallbackUnaryHandler<
                ::sdv::edge::comfort::seats::v1::CurrentPositionRequest,
                ::sdv::edge::comfort::seats::v1::CurrentPositionReply>*>(handler)
                ->SetMessageAllocator(allocator);
        }
        ~WithCallbackMethod_CurrentPosition() override { BaseClassMustBeDerivedFromService(this); }
        // disable synchronous version of this method
        ::grpc::Status CurrentPosition(
            ::grpc::ServerContext* /*context*/,
            const ::sdv::edge::comfort::seats::v1::CurrentPositionRequest* /*request*/,
            ::sdv::edge::comfort::seats::v1::CurrentPositionReply* /*response*/) override {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
        virtual ::grpc::ServerUnaryReactor*
        CurrentPosition(::grpc::CallbackServerContext* /*context*/,
                        const ::sdv::edge::comfort::seats::v1::CurrentPositionRequest* /*request*/,
                        ::sdv::edge::comfort::seats::v1::CurrentPositionReply* /*response*/) {
            return nullptr;
        }
    };
    typedef WithCallbackMethod_Move<
        WithCallbackMethod_MoveComponent<WithCallbackMethod_CurrentPosition<Service>>>
                            CallbackService;
    typedef CallbackService ExperimentalCallbackService;
    template <class BaseClass> class WithGenericMethod_Move : public BaseClass {
    private:
        void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}

    public:
        WithGenericMethod_Move() { ::grpc::Service::MarkMethodGeneric(0); }
        ~WithGenericMethod_Move() override { BaseClassMustBeDerivedFromService(this); }
        // disable synchronous version of this method
        ::grpc::Status Move(::grpc::ServerContext* /*context*/,
                            const ::sdv::edge::comfort::seats::v1::MoveRequest* /*request*/,
                            ::sdv::edge::comfort::seats::v1::MoveReply* /*response*/) override {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
    };
    template <class BaseClass> class WithGenericMethod_MoveComponent : public BaseClass {
    private:
        void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}

    public:
        WithGenericMethod_MoveComponent() { ::grpc::Service::MarkMethodGeneric(1); }
        ~WithGenericMethod_MoveComponent() override { BaseClassMustBeDerivedFromService(this); }
        // disable synchronous version of this method
        ::grpc::Status
        MoveComponent(::grpc::ServerContext* /*context*/,
                      const ::sdv::edge::comfort::seats::v1::MoveComponentRequest* /*request*/,
                      ::sdv::edge::comfort::seats::v1::MoveComponentReply* /*response*/) override {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
    };
    template <class BaseClass> class WithGenericMethod_CurrentPosition : public BaseClass {
    private:
        void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}

    public:
        WithGenericMethod_CurrentPosition() { ::grpc::Service::MarkMethodGeneric(2); }
        ~WithGenericMethod_CurrentPosition() override { BaseClassMustBeDerivedFromService(this); }
        // disable synchronous version of this method
        ::grpc::Status CurrentPosition(
            ::grpc::ServerContext* /*context*/,
            const ::sdv::edge::comfort::seats::v1::CurrentPositionRequest* /*request*/,
            ::sdv::edge::comfort::seats::v1::CurrentPositionReply* /*response*/) override {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
    };
    template <class BaseClass> class WithRawMethod_Move : public BaseClass {
    private:
        void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}

    public:
        WithRawMethod_Move() { ::grpc::Service::MarkMethodRaw(0); }
        ~WithRawMethod_Move() override { BaseClassMustBeDerivedFromService(this); }
        // disable synchronous version of this method
        ::grpc::Status Move(::grpc::ServerContext* /*context*/,
                            const ::sdv::edge::comfort::seats::v1::MoveRequest* /*request*/,
                            ::sdv::edge::comfort::seats::v1::MoveReply* /*response*/) override {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
        void RequestMove(::grpc::ServerContext* context, ::grpc::ByteBuffer* request,
                         ::grpc::ServerAsyncResponseWriter<::grpc::ByteBuffer>* response,
                         ::grpc::CompletionQueue*                               new_call_cq,
                         ::grpc::ServerCompletionQueue* notification_cq, void* tag) {
            ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq,
                                               notification_cq, tag);
        }
    };
    template <class BaseClass> class WithRawMethod_MoveComponent : public BaseClass {
    private:
        void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}

    public:
        WithRawMethod_MoveComponent() { ::grpc::Service::MarkMethodRaw(1); }
        ~WithRawMethod_MoveComponent() override { BaseClassMustBeDerivedFromService(this); }
        // disable synchronous version of this method
        ::grpc::Status
        MoveComponent(::grpc::ServerContext* /*context*/,
                      const ::sdv::edge::comfort::seats::v1::MoveComponentRequest* /*request*/,
                      ::sdv::edge::comfort::seats::v1::MoveComponentReply* /*response*/) override {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
        void RequestMoveComponent(::grpc::ServerContext* context, ::grpc::ByteBuffer* request,
                                  ::grpc::ServerAsyncResponseWriter<::grpc::ByteBuffer>* response,
                                  ::grpc::CompletionQueue*       new_call_cq,
                                  ::grpc::ServerCompletionQueue* notification_cq, void* tag) {
            ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq,
                                               notification_cq, tag);
        }
    };
    template <class BaseClass> class WithRawMethod_CurrentPosition : public BaseClass {
    private:
        void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}

    public:
        WithRawMethod_CurrentPosition() { ::grpc::Service::MarkMethodRaw(2); }
        ~WithRawMethod_CurrentPosition() override { BaseClassMustBeDerivedFromService(this); }
        // disable synchronous version of this method
        ::grpc::Status CurrentPosition(
            ::grpc::ServerContext* /*context*/,
            const ::sdv::edge::comfort::seats::v1::CurrentPositionRequest* /*request*/,
            ::sdv::edge::comfort::seats::v1::CurrentPositionReply* /*response*/) override {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
        void RequestCurrentPosition(::grpc::ServerContext* context, ::grpc::ByteBuffer* request,
                                    ::grpc::ServerAsyncResponseWriter<::grpc::ByteBuffer>* response,
                                    ::grpc::CompletionQueue*       new_call_cq,
                                    ::grpc::ServerCompletionQueue* notification_cq, void* tag) {
            ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq,
                                               notification_cq, tag);
        }
    };
    template <class BaseClass> class WithRawCallbackMethod_Move : public BaseClass {
    private:
        void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}

    public:
        WithRawCallbackMethod_Move() {
            ::grpc::Service::MarkMethodRawCallback(
                0,
                new ::grpc::internal::CallbackUnaryHandler<::grpc::ByteBuffer, ::grpc::ByteBuffer>(
                    [this](::grpc::CallbackServerContext* context,
                           const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) {
                        return this->Move(context, request, response);
                    }));
        }
        ~WithRawCallbackMethod_Move() override { BaseClassMustBeDerivedFromService(this); }
        // disable synchronous version of this method
        ::grpc::Status Move(::grpc::ServerContext* /*context*/,
                            const ::sdv::edge::comfort::seats::v1::MoveRequest* /*request*/,
                            ::sdv::edge::comfort::seats::v1::MoveReply* /*response*/) override {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
        virtual ::grpc::ServerUnaryReactor* Move(::grpc::CallbackServerContext* /*context*/,
                                                 const ::grpc::ByteBuffer* /*request*/,
                                                 ::grpc::ByteBuffer* /*response*/) {
            return nullptr;
        }
    };
    template <class BaseClass> class WithRawCallbackMethod_MoveComponent : public BaseClass {
    private:
        void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}

    public:
        WithRawCallbackMethod_MoveComponent() {
            ::grpc::Service::MarkMethodRawCallback(
                1,
                new ::grpc::internal::CallbackUnaryHandler<::grpc::ByteBuffer, ::grpc::ByteBuffer>(
                    [this](::grpc::CallbackServerContext* context,
                           const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) {
                        return this->MoveComponent(context, request, response);
                    }));
        }
        ~WithRawCallbackMethod_MoveComponent() override { BaseClassMustBeDerivedFromService(this); }
        // disable synchronous version of this method
        ::grpc::Status
        MoveComponent(::grpc::ServerContext* /*context*/,
                      const ::sdv::edge::comfort::seats::v1::MoveComponentRequest* /*request*/,
                      ::sdv::edge::comfort::seats::v1::MoveComponentReply* /*response*/) override {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
        virtual ::grpc::ServerUnaryReactor*
        MoveComponent(::grpc::CallbackServerContext* /*context*/,
                      const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/) {
            return nullptr;
        }
    };
    template <class BaseClass> class WithRawCallbackMethod_CurrentPosition : public BaseClass {
    private:
        void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}

    public:
        WithRawCallbackMethod_CurrentPosition() {
            ::grpc::Service::MarkMethodRawCallback(
                2,
                new ::grpc::internal::CallbackUnaryHandler<::grpc::ByteBuffer, ::grpc::ByteBuffer>(
                    [this](::grpc::CallbackServerContext* context,
                           const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) {
                        return this->CurrentPosition(context, request, response);
                    }));
        }
        ~WithRawCallbackMethod_CurrentPosition() override {
            BaseClassMustBeDerivedFromService(this);
        }
        // disable synchronous version of this method
        ::grpc::Status CurrentPosition(
            ::grpc::ServerContext* /*context*/,
            const ::sdv::edge::comfort::seats::v1::CurrentPositionRequest* /*request*/,
            ::sdv::edge::comfort::seats::v1::CurrentPositionReply* /*response*/) override {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
        virtual ::grpc::ServerUnaryReactor*
        CurrentPosition(::grpc::CallbackServerContext* /*context*/,
                        const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/) {
            return nullptr;
        }
    };
    template <class BaseClass> class WithStreamedUnaryMethod_Move : public BaseClass {
    private:
        void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}

    public:
        WithStreamedUnaryMethod_Move() {
            ::grpc::Service::MarkMethodStreamed(
                0,
                new ::grpc::internal::StreamedUnaryHandler<
                    ::sdv::edge::comfort::seats::v1::MoveRequest,
                    ::sdv::edge::comfort::seats::v1::MoveReply>(
                    [this](::grpc::ServerContext* context,
                           ::grpc::ServerUnaryStreamer<::sdv::edge::comfort::seats::v1::MoveRequest,
                                                       ::sdv::edge::comfort::seats::v1::MoveReply>*
                               streamer) { return this->StreamedMove(context, streamer); }));
        }
        ~WithStreamedUnaryMethod_Move() override { BaseClassMustBeDerivedFromService(this); }
        // disable regular version of this method
        ::grpc::Status Move(::grpc::ServerContext* /*context*/,
                            const ::sdv::edge::comfort::seats::v1::MoveRequest* /*request*/,
                            ::sdv::edge::comfort::seats::v1::MoveReply* /*response*/) override {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
        // replace default version of method with streamed unary
        virtual ::grpc::Status
        StreamedMove(::grpc::ServerContext* context,
                     ::grpc::ServerUnaryStreamer<::sdv::edge::comfort::seats::v1::MoveRequest,
                                                 ::sdv::edge::comfort::seats::v1::MoveReply>*
                         server_unary_streamer) = 0;
    };
    template <class BaseClass> class WithStreamedUnaryMethod_MoveComponent : public BaseClass {
    private:
        void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}

    public:
        WithStreamedUnaryMethod_MoveComponent() {
            ::grpc::Service::MarkMethodStreamed(
                1, new ::grpc::internal::StreamedUnaryHandler<
                       ::sdv::edge::comfort::seats::v1::MoveComponentRequest,
                       ::sdv::edge::comfort::seats::v1::MoveComponentReply>(
                       [this](::grpc::ServerContext* context,
                              ::grpc::ServerUnaryStreamer<
                                  ::sdv::edge::comfort::seats::v1::MoveComponentRequest,
                                  ::sdv::edge::comfort::seats::v1::MoveComponentReply>* streamer) {
                           return this->StreamedMoveComponent(context, streamer);
                       }));
        }
        ~WithStreamedUnaryMethod_MoveComponent() override {
            BaseClassMustBeDerivedFromService(this);
        }
        // disable regular version of this method
        ::grpc::Status
        MoveComponent(::grpc::ServerContext* /*context*/,
                      const ::sdv::edge::comfort::seats::v1::MoveComponentRequest* /*request*/,
                      ::sdv::edge::comfort::seats::v1::MoveComponentReply* /*response*/) override {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
        // replace default version of method with streamed unary
        virtual ::grpc::Status StreamedMoveComponent(
            ::grpc::ServerContext* context,
            ::grpc::ServerUnaryStreamer<::sdv::edge::comfort::seats::v1::MoveComponentRequest,
                                        ::sdv::edge::comfort::seats::v1::MoveComponentReply>*
                server_unary_streamer) = 0;
    };
    template <class BaseClass> class WithStreamedUnaryMethod_CurrentPosition : public BaseClass {
    private:
        void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}

    public:
        WithStreamedUnaryMethod_CurrentPosition() {
            ::grpc::Service::MarkMethodStreamed(
                2,
                new ::grpc::internal::StreamedUnaryHandler<
                    ::sdv::edge::comfort::seats::v1::CurrentPositionRequest,
                    ::sdv::edge::comfort::seats::v1::CurrentPositionReply>(
                    [this](::grpc::ServerContext* context,
                           ::grpc::ServerUnaryStreamer<
                               ::sdv::edge::comfort::seats::v1::CurrentPositionRequest,
                               ::sdv::edge::comfort::seats::v1::CurrentPositionReply>* streamer) {
                        return this->StreamedCurrentPosition(context, streamer);
                    }));
        }
        ~WithStreamedUnaryMethod_CurrentPosition() override {
            BaseClassMustBeDerivedFromService(this);
        }
        // disable regular version of this method
        ::grpc::Status CurrentPosition(
            ::grpc::ServerContext* /*context*/,
            const ::sdv::edge::comfort::seats::v1::CurrentPositionRequest* /*request*/,
            ::sdv::edge::comfort::seats::v1::CurrentPositionReply* /*response*/) override {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
        // replace default version of method with streamed unary
        virtual ::grpc::Status StreamedCurrentPosition(
            ::grpc::ServerContext* context,
            ::grpc::ServerUnaryStreamer<::sdv::edge::comfort::seats::v1::CurrentPositionRequest,
                                        ::sdv::edge::comfort::seats::v1::CurrentPositionReply>*
                server_unary_streamer) = 0;
    };
    typedef WithStreamedUnaryMethod_Move<
        WithStreamedUnaryMethod_MoveComponent<WithStreamedUnaryMethod_CurrentPosition<Service>>>
                    StreamedUnaryService;
    typedef Service SplitStreamedService;
    typedef WithStreamedUnaryMethod_Move<
        WithStreamedUnaryMethod_MoveComponent<WithStreamedUnaryMethod_CurrentPosition<Service>>>
        StreamedService;
};

} // namespace v1
} // namespace seats
} // namespace comfort
} // namespace edge
} // namespace sdv

#endif // GRPC_service_2fseats_2eproto__INCLUDED
